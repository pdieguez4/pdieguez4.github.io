<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&family=Montserrat:wght@700&display=swap"
    rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/js/all.min.js"></script>
  <script src="https://mszabo4.github.io/robotica/arduino/programacio/arduino.min.js"></script>

  <script>hljs.highlightAll();</script>
  <title>Programaci√≥</title>
<style>
    body {
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(to right, #0f172a, #1e293b);
      color: #e2e8f0;
      margin: 0;
      padding: 0;
    }

    .navbar {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background: linear-gradient(45deg, #1e40af, #0ea5e9);
      padding: 12px 24px;
      border-bottom: 4px solid #38bdf8;
      z-index: 10;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }

    .navbar-brand {
      display: flex;
      align-items: center;
      color: #ffffff !important;
      font-family: 'Montserrat', sans-serif;
      font-size: 1.75rem;
      font-weight: 700;
      letter-spacing: 2px;
      transition: color 0.3s ease-in-out;
    }

    .navbar-brand:hover {
      color: #38bdf8 !important;
    }

    .nav-link {
      color: #ffffff !important;
      font-weight: 600;
      margin-right: 15px;
      position: relative;
      transition: color 0.3s ease;
    }

    .nav-link:hover {
      color: #38bdf8 !important;
    }

    .content-container {
      margin: 140px auto 50px auto;
      padding: 40px;
      max-width: 900px;
      background-color: #1e293b;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
      border-radius: 15px;
      border-left: 5px solid #38bdf8;
      border-right: 5px solid #38bdf8;
      animation: fadeIn 1.2s ease-in-out;
    }

    h1 {
      color: #0ea5e9;
      font-family: 'Montserrat', sans-serif;
      font-size: 2.5rem;
      font-weight: 700;
      text-align: center;
    }

    .custom-button {
      background: linear-gradient(135deg, #0ea5e9, #1e40af);
      color: white;
      border: none;
      padding: 18px 40px;
      font-size: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
      border-radius: 50px;
      font-weight: bold;
      text-transform: uppercase;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }

    .custom-button:hover {
      background: linear-gradient(135deg, #38bdf8, #1e40af);
      transform: scale(1.1);
      box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
    }

    table {
      width: 60%;
      border-collapse: collapse;
      margin: 20px auto;
      background-color: #1e293b;
      border-radius: 10px;
      overflow: hidden;
    }

    th, td {
      border: 1px solid #0ea5e9;
      padding: 12px;
      text-align: center;
      color: #e2e8f0;
    }

    thead {
      background: #0ea5e9;
      font-weight: bold;
      color: #fff;
    }

    tbody tr:nth-child(even) {
      background-color: #172030;
    }

    tbody tr:hover {
      background-color: #0f172a;
    }

    @keyframes fadeIn {
      0% {
        opacity: 0;
        transform: translateY(20px);
      }
      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }
</style>
    <script>
        function copyCode(button) {
            const codeBlock = button.nextElementSibling.innerText;
            navigator.clipboard.writeText(codeBlock).then(() => {
                button.innerHTML = '<i class="fas fa-check"></i>';
                setTimeout(() => { button.innerHTML = '<i class="fas fa-copy"></i>'; }, 2000);
            });
        }
    </script>
</head>

<body>
    <!-- Navbar -->
    <nav class="navbar navbar-expand-lg">
        <div class="container-fluid">
            <a class="navbar-brand" href="https://mszabo4.github.io">
                <img src="https://mszabo4.github.io/logo.png" alt="Logo" width="50">
                Web de Miguel Angel
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav"
                aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul.n class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="https://mszabo4.github.io">Inici</a>
                    </li>
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button"
                            data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                            Programaci√≥
                        </a>
                        <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                            <a class="dropdown-item" href="https://mszabo4.github.io/cara">Cara interactiva</a>
                            <a class="dropdown-item" href="https://mszabo4.github.io/cara1">Cara interactiva nova</a>
                            <a class="dropdown-item" href="https://mszabo4.github.io/ocell">Ocell</a>
                            <a class="dropdown-item" href="https://mszabo4.github.io/reproducer">Coldplay</a>
                            <a class="dropdown-item" href="https://mszabo4.github.io/astronomia">Astronomia</a>
                            <a class="dropdown-item" href="https://mszabo4.github.io/astronomia/animacio">Astronomia</a>
                            <a class="dropdown-item" href="https://mszabo4.github.io/openair">Openair</a>
                        </div>
                    </li>
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown2" role="button"
                            data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                            Rob√≤tica
                        </a>
                        <div class="dropdown-menu" aria-labelledby="navbarDropdown2">
                            <a class="dropdown-item" href="https://mszabo4.github.io/robotica/cdirecte">Cinem√†tica
                                directa</a>
                            <a class="dropdown-item" href="https://mszabo4.github.io/robotica/cinversa">Cinem√†tica
                                inversa</a>
                            <a class="dropdown-item" href="https://mszabo4.github.io/reproducer">Coldplay</a>
                            <a class="dropdown-item" href="https://mszabo4.github.io/robotica/arduino">Arduino</a>
                        </div>
                    </li>
                    <li class="nav-item">
                    </li>
                </ul.n>
            </div>
        </div>
    </nav>

    <div class="content-container">
        <h3>El meu primer codi: Blink</h3>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
//El meu primer codi: Blink
void setup() { //Codi que s'executa una vegada i √©s la configuraci√≥.
  pinMode(13, OUTPUT); //Estem dient que el pin 13 √©s una sortida de corrent o OUTPUT on puc 
    // connectar un led.
}

void loop() { //√âs un codi que s'executa sense parar fins que desconnecto l'Arduino o li dono una 
    // instrucci√≥ de parada.
 digitalWrite(13, HIGH); // <b>digitalWrite</b> √©s una sortida digital i permet encendre i apagar
    // Nom√©s t√© 2 valors, HIGH i LOW (Enc√®s i apagat)
 delay(500);//√âs el temps en milisegons que ha d'estar, en aquest cas enc√®s.
 digitalWrite(13, LOW);//Aqui <b>digitalWrite</b> fa que s'apagui
 delay(500);
}
    </code></pre>

    </div>

    <div class="content-container">
        <h3>Codi Blink amb un condicional</h3>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
//Codi Blink amb un condicional
        
int ledPin = 13;
int delayPeriod = 100;
        
void setup() {
    pinMode(ledPin, OUTPUT);
}
        
void loop() {
    digitalWrite(ledPin, HIGH);
    delay(delayPeriod);
    digitalWrite(ledPin, LOW);
    delay(delayPeriod);
    delayPeriod = delayPeriod + 100; //Augmenta el temps 100 milisegons cada vegada
    if (delayPeriod == 1000) { //Quan arriba a 1000 milisegons torna a comen√ßar, aix√≤ significa que quan arriba a 1000 torna a comen√ßar 
        //perqu√® hem posat que el delayPeriod sigui 100 de nou. 
        //Cada vegada √©s m√©s lent perqu√® el temps que triga en encendre i apagar-se √©s major.
        //Si vulgues que cada vegada sigui m√©s r√†pid, i s'hauria de canviar varies coses: al principi del codi canviar la variable de 
        //int delayPeriod = 1000, a final de codi posar el menys a "delayPeriod = delayPeriod - 100", i finalment canviar el condicional per:
        //if (delayPeriod == 100); delayPeriod = 1000;
        //Si vull que el canvi sigui m√©s lent s'hauria de posar un n√∫mero m√©s alt en "delayPeriod = delayPeriod + X"
        //Si vull que el canvi sigui m√©s r√†pid s'hauria de posar un n√∫mero m√©s petit en "delayPeriod = delayPeriod + X"
    delayPeriod = 100;
    }
}
    </code></pre>

    </div>
    <div class="content-container">
        <h3>Operacions matem√†tiques (√ötils per sensors o per problemes matem√†tics)</h3>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            //Operacions matem√†tiques (√ötils per sensors o per problemes matem√†tics)
            void setup() {
              Serial.begin(9600);//Hem de connectar l'Arduino a la consola s√®rie a 9600 bauds, que s√≥n 9600 s√≠mbols per segon
                //I poden ser aproximadament 9600 bits per segon, per√≤, en alguns casos, necessitem m√©s d'un bit per un s√≠mbol
              int a = 2;
              int b = 2;
              int c = a + b;//Llenguatge arduino accepta les operacions matem√†tiques b√†siques
              Serial.println(c); 
            }
            void loop() {}
            </code></pre>
    </div>
    <div class="content-container">
        <h3>Exemple de temperatura amb operacions matem√†tiques</h3>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            //Exemple de temperatura amb operacions matem√†tiques
            
            void setup() {
              Serial.begin(9600);
              int degC = 20; //Representa que el sensor ja ha agafat 20 graus i els volem convertir a Fahrenheit
              int degF;
              degF = degC * 9 / 5 + 32;
              Serial.println(degF); //Fes una impressi√≥ a la consola de l'ordinador en una l√≠nea println el valor de la variable fahrenheit.
            }
            void loop(){}
            </code></pre>
    </div>
    <div class="content-container">
        <p>En el seg√ºent codi podem veure com definir unes variables globals i les apliquem moltes vegades repetides
            dins del mateix codi. √âs un codi molt repetitiu.</p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">

int ledPin = 13;
int delayPeriod = 250;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);

 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);

 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);

 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 
 delay(3000);
}
</code></pre>
    </div>
    <div class="content-container">
        <p> Amb el seg√ºent codi, aconseguim el mateix resultat que m√©s amunt, es a dir,
            encendre i apagar 20 vegades amb un delay de 250 milisegons, per√≥ no ho escribim 20
            vegades, si no que fem un cicle for.</p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            // 02_08_blik_20_for
        
        int ledPin = 13;
        int delayPeriod = 250;
        
        void setup() {
          pinMode(ledPin, OUTPUT);
        }
        
        void loop() {
          for (int i = 0; i < 20; i ++) { //Dintre del cicle for, tenim les condicions que ha de complir el cicle
              //que s√≥n des de i = 0 fins a i = 20, ves augmentant un en un. O sigui i++ que es el mateix que i = i + 1
              //Si volgu√©s podria canviar les condicions. fent que els numeros augmentesin diferent
              //(Per exemple i = i + 5)
              
           digitalWrite(ledPin, HIGH);
           delay(delayPeriod);
           digitalWrite(ledPin, LOW);
           delay(delayPeriod);
          }
         delay(3000);
        }
        </code></pre>
    </div>
    <div class="content-container">
        <p> En el codi anterior, hem dit que repeteixi 20 vegades per√≤ es repeteix infinites vegades perqu√© es repeteix
            20 vegades en un void loop. En el seg√ºent codi, posarem un contador i quan arribi a 20 repeticions s'aturar√†
        </p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
        // 02_09_blink_20_loop (Aqui es nota perqu√©)
        
        int ledPin = 13;
        int delayPeriod = 100;
        int count = 0;
        
        void setup() {
          pinMode(ledPin, OUTPUT);
        }
        
        void loop() {
         digitalWrite(ledPin, HIGH);
         delay(delayPeriod);
         digitalWrite(ledPin, LOW);
         delay(delayPeriod);
         count ++; //"Count" es una variable global que podria ser local, perqu√® nom√©s afecta al loop.
            //si escric "int count; count ++;" estaria definint una variable local dintre del loop, i no es pot usar en una altre funci√≥ que jo defineixi o
            //al setup
         if (count == 20) { //Quan el comtador arriba a 20 deixa de fer parpadeigs de 100 milisegons i fa una aturada de 3 segons abans de tornar a comen√ßar
           count = 0;
           delay(3000);
         }
        }
         // Dos iguals vol dir que es exactament igual. Si posem 3 iguals "===" es una comparaci√≥ estricta es a dir una comparaci√≥
        // estricta, que compara tamb√© el tipus de variable. Si posem un igual "=" √©s una assignaci√≥ que pot ser temporal o constant
        // si es posa "const" davant es 
        </code></pre>
    </div>
    <div class="content-container">
        <p> El seg√ºent codi es el primer exemple de creaci√≥ d'una funci√≥. Una funci√≥ es com un programa dins dins d'un
            programa.</p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            // 03_01_blink_function
        
        const int ledPin = 13;
        const int delayPeriod = 250;
        
        void setup() {
          pinMode(ledPin, OUTPUT);
        }
        // Aquest codi es el principal, anomenat com a "main" en alguns llenguatges. √âs el que s'aplica continuadament. En aquest cas el "void loop()"
        // el loop repeteix 20 vegades el flash.
        // Com cridem una funci√≥?
        // Nom√©s cal posar el nom de la funci√≥ dintre del loop per cridar-la i que s'executi sempre.
        void loop() {
          for (int i = 0; i < 20; i ++) {
            flash();
          }
         delay(3000);
        }
        // per crear una funci√≥ nom√©s cal escriure el nom de la funci√≥ i uns parentesis. Si hagu√©s alguna cosa entre parentesi
        //serian els parametres o arguments de la funci√≥. La paraula "void" en aquest cas es equivalent a la paraula "function" de javascript.
        //triem un nom explicatiu del que fa la funci√≥, i dintre de les claus posem les linees de codi que s'han d'executar quan la cridem pel seu
        //nom dintre del void loop (per exemple). 
        void flash() { 
           digitalWrite(ledPin, HIGH);
           delay(delayPeriod);
           digitalWrite(ledPin, LOW);
           delay(delayPeriod);
        }
        </code></pre>
    </div>
    <div class="content-container">
        <p>A continuaci√≥ veurem el codi flash per√≤ amb par√†metres. </p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            // 03_03_blink_functrion_params
        
        const int ledPin = 13;
        const int delayPeriod = 250;
        
        void setup() {
          pinMode(ledPin, OUTPUT);
        }
        
        void loop() {
          flash(20, delayPeriod);
          delay(3000);
        }
        // Podem veure que la funci√≥ te dos par√†metres que son 2 nombres enters i que s'anomenen "numFlashes" i "d"
        // numFlashes no esta definit com a variable global, √©s una variable local definida dins de la funci√≥ "flash"
        // i no te un valor predeterminat, nom√©s ha de complir que sigui un valor enter. El mateix per a la variable "d"
        void flash(int numFlashes, int d) {
            for (int i = 0; i numFlashes; i++) {
            digitalWrite(ledPin, HIGH);
            delay(d);
            digitalWrite(ledPin, LOW);
            delay(d);
            }
            }

        </code></pre>

        <div class="content-container">
            <h1>Funcions en Arduino</h1>
            <p>Les funcions d'arduino s√≥n semblants a les funcions que veiem a cinem√†tica directa i inversa. En el cas de la cinem√†tica rob√≤tica 
                utilitzavem funcions Javascript dintre d'un codi HTML. Avans cada funci√≥ com per exemple, calculatePosition () era una funci√≥ 
                sense arguments o par√†metres que estava identificada amb un bloc de codianomenat function i s'executava quan clicavem un bot√≥. 
                Dintre d'aquest bloc hi havien instruccions que permeten fer c√†lculs matem√†tics. En el seg√ºent codi d'arduino, tenim una funcion 
                flash amb dos per√†metres que eren n√∫meros enters anomenat ledPin i de delayPeriod que identifiquen el pin que est√† connectat i el 
                temps que ha d'estar enc√®s o apagat.
            </p>
          <p> Ara farem que un bucle for ss'executi 20 o x vegades dintre d'unbucle for localitzat dintre d'un bucle infinit loop. Ho aconseguim 
                amb la paraula clau static, que fa que una variable s'inicialitzi una vegada que correm el codi  i mai m√©s. La paraula static es deriva 
                del llenguatge C i Arduino √©s un derviat de C++ i Processing, </p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            // 03_03_blink_20_faulty

const int ledPin = 13;
const int delayPeriod = 250;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
  int count = 0;
  digitalWrite(ledPin, HIGH);
  delay(delayPeriod);
  digitalWrite(ledPin, LOW);
  delay(delayPeriod);
  count ++;
  if (count == 20) {
    count = 0;
    delay(3000);
  }
}
            </code></pre>
        </div>

        <div class="content-container">
            <h1>Arrays i Strings</h1>
            <p>Una Array √©s una forma de contenir un llistat de valors, moltes vegades s√≥n valors enters i s'accedeix amb ells per la 
                seva posici√≥, sent la primera posici√≥ [0] del array o element 0. El codi seg√ºent el que fa √©s a la primera linia defineix una 
                array amb 9 valors, i els imprimeix en el monitor s√®rie els seus valors. Ser√† √∫til pel nostre codi morse.
            </p>
            <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
                
int durations[] = {200, 200, 200, 500, 500, 500, 200, 200, 200};

void setup() {
  Serial.begin(9600);  
  for (int i = 0; i < 9; i++) {
    Serial.println(durations[i]);
  }
}

void loop() {

}
            </code></pre>
        </div>
        
        <div class="content-container">
            <p>El codi seg√ºent ja √©s un codi morse, perqu√® combina una array, un bucle for que llegeix l'array i l'aplica a la funci√≥ flash, 
                d'aquesta forma √©s com si escrivis flash(200), flash(200), flash(200), flash(500), flash(500), flash(500), flash(200), flash(200), flash(200).
            </p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
const int ledPin = 13;

int durations[] = {200, 200, 200, 500, 500, 500, 200, 200, 200};

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop()  {
  for (int i = 0; i < 9; i++) {
    flash(durations[i]);
  }
  delay(1000);
}

void flash(int duration) {
   digitalWrite(ledPin, HIGH);
   delay(duration);
   digitalWrite(ledPin, LOW);
   delay(duration);
}
        </code></pre>
        </div>

        <div class="content-container">
            <p>Puc crear una funci√≥ que em serveix per quatre lletres i nom√®s quan la crido he de posar el n√∫mero de repeticions com 
                par√†metres o arguments</p>
        </div>

        <div class="content-container">
            <h1>Normes internacionals de codi Morse</h1>
            <ul>
                <li>Una l√≠nia (dash) √©s igual a tres punts</li>
                <li>L'espai entre les parts d'una meteixa lletra √©s igual a un punt (dot). (S = ¬∑¬∑¬∑, l'espai entre cada punt √©s un punt)</li>
                <li>L'espai entre dues lletres de la mateixa paraula s√≥n tres punts (Per exemple entre las S i la O de SOS)</li>
                <li>L'espai entre dues parules √©s igual a set punts (Pa ¬∑¬∑¬∑¬∑¬∑¬∑¬∑ tom√†quet)</li> 
            </ul>
            <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
                void eosz (int numFlashes) {
                    for (int i = 0; i < numFlashes; i++) {
                        digitalWrite(ledPin, HIGH);
                        delay(200);
                        digitalWrite(ledPin, LOW);
                        delay(200);
                    }
                }

                void loop(){
                    eosz(1); // Aix√≤ √©s la lletra e
                    eosz(3); // Aix√≤ √©s la lletra s
                    eosz(2); // Aix√≤ √©s la lletra o
                }
            </code></pre>

            <p>Crearem una funci√≥ que ser√† v√†lida pels punts repetits i per les linies repetides amb dos par√†ametres.</p>

            <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">


                void eosztmo (int numFlashes, int d) {
                    for (int i = 0; i < numFlashes; i++) {
                        digitalWrite(ledPin, HIGH);
                        delay(d);
                        digitalWrite(ledPin, LOW);
                        delay(d);
                    }
                }

                void loop(){
                    eosztmo(1, 600); //Aix√≤ √©s la t
                    eosztmo(3, 600); //Aix√≤ √©s la o
                    eosztmo(3, 200); //Aix√≤ √©s la s
                    eosztmo(1, 200); //Aix√≤ √©s la e
                }
            </code></pre>
        </div>
        <div class="content-container">
        <p>L'objectiu del codi seg√ºent √©s entendre que les cadenes o strings s√≥n conjunts de car√†cters ASCII i podem accedir
        amb ells amb arrays que estan formats per par√®ntesis quadrats i el primer element √©s el 0. En llenguatge C i derivats
        del C com Arduino podem utilitzar punters o pointers que permeten apuntar a un element. En python o JavaScript no hi ha punters</p>
       <p>A continuaci√≥ veuras els caracter ASCII en una taula, que son els utilitzats en els strings o cadenes</p>
       <p>La taula seg√ºent est√† basada en un codi binari de 7 bits, perque 2 elevat a 7 (2^7) es 128, hi hauran desde 0 a 
               127 car√†cters diferents</p>
        <table>
        <thead>
        <tr>
        <th>ASCII</th>
        <th>DECIMAL</th>
        <th>BINARI</th>
        </tr>
        </thead>

        <tbody>
        <tr>
            <td>A-Z</td>
            <td>65-90</td>
            <td>0b000001-0b1011010</td>
         </tr>
        <tr>
            <td>a-z</td>
            <td>97-122</td>
            <td>0b110000-0b11001</td>
        </tr>
        <tr>
            <td>espai</td>
            <td>32</td>
            <td>0b0100000</td>
        </tr>
        </tbody>
        </table>
        <p>ASCII significa American Standard Code for Information Interchange i va ser descrit a l'any 1967 amb l'objectiu 
            d'intercambiar informaci√≥ amb ordinadors</p>
        <p>UTF8 √©s un sistema Unicode Transformation Format que permet escriure m√©s d'un mili√≥ de car√†cters diferents
            ‚ÄúüôÇ‚Äù U+1F642</p>       
        <div class="content-container">
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">


            // sketch 05-03

           char message[] = "Hello"; //Hi ha u

           void setup() {
           Serial.begin(9600);
           message[0] = 'h';
           }

           void loop() {
           Serial.println(message);
           delay(1000);
            }
          
        </code>
        </pre>
        </div>
          
 <div class="content-container">
        <h3>Import√†ncia dels punters + Exemple de codi Morse</h3>
   <p>Hi ha llenguatges amb i sense punters.</p>
   <ul>
     <li> Exemples de llenguatges amb: C i els seus derivats com Arduino</li>
     <li> Exemples de llenguatges sense: Python i JavaScript</li>
   </ul>
   <p>El punter llegeix una adre√ßa a la mem√≤ria de l'ordinador i la posici√≥ de l'adre√ßa d'ordinador, i manipular-la</p>
   <p>El punter serveix per tenir un control total per part del programador de la mem√≤ria i els recursos de l'ordinador</p>
   <p>El problema que t√© √©s que pot provocar errors a la mem√≤ria o accesos no pemesos si no saps com fer funcionar correctament el punter</p>
   <p>Els dos s√≠mbols per utilitzar punters s√≥n: L'arterisc '*', que serveix per llegir el contingut de l'adre√ßa de mem√≤ria. I l'ampersand '&', que llegeix la posici√≥ de l'adre√ßa de mem√≤ria/p>
   <p>La mem√≤ria de l'ordinador la podem imaginar com caixes d'una llista on cada caixa t√© un valor unic assiganat en hexadecimal que comen√ßa per 0x. Cada caixa t√© un contingut que pot ser buit(0) o pot contenir un valor</p>

   <h4>Operacions avan√ßades amb punters</h4>
   <ul>
   <li><b>Acc√©s directe a la mem√≤ria:</b> Permet modificar valors en posicions espec√≠fiques.</li>
   <li><b>Manipulaci√≥ eficient d'arrays i strings (cadenes):</b> L'array √©s en una lista d'adreces amb principi i final amb un punter al primer element</li>
   <li><b>Passar grans quantitats de dades a funcions:</b> En lloc de copiar valors, els punters passen la seva adre√ßa, estalviant mem√≤ria i temps. Aquest √©s un dels motius per els que C i derivats s√≥n m√©s r√†pids que Pytho.</li>
   <li><b>Creacci√≥ d'estructures din√†miques:</b> √âs pot crear coses com llistes enlla√ßades, grafics... de forma m√©s f√†cil</li>
   <li><b>Interacci√≥ amb microcontroladors senzilla:</b> Els microcontroladors utilitzen llenguatgges de baix nivell (lox-level languages) que s√≥n m√©s propers al hardware. Encara qu√©, gr√†cies a l'augment de la mem√≤ria, s'han pogut crear llenguatges com microPython o circuitPython </li>
   </ul>
   
   <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
// Al principi del codi, abans de la funci√≥ de configuraci√≥ "setup" i la funci√≥ principal 
// "loop" que s'executa continuament, hem d'escriure sempre variables o constants.
// A m√©s, al principi del codi trobem les constants i variables globals, anomenades aix√≠ perqu√® es poden cridar
// o executar des de qualsevol part del codi, a diferencia de les variables locals que es 
// defineixen i s'utilitzen dintre de la mateixa funci√≥ "loop" o una funci√≥ addicional.
// Davant de les variables i constants globals hauriem d'afegir les biblioteques necess√†ries per 
// fer funcionar el nostre codi ( amb "#include <nom_biblioteca.h> ) l'extensi√≥ "h" deriva de C
// i significa "biblioteca de headers" o encap√ßalaments.        
     const int ledPin = 13;
const int dotDelay = 200

// "const" vol dir que la variable no es modificar√† dins del codi, "int" vol dir integer, o sigui
// que el nombre que agafem haur√† de ser enter, ja que els pins tenen n√∫meros enters. El pin 13
// √©s especial, t√© una resist√®ncia interna en el cas d'Arduino uno que permet connectar directament
// un led, perqu√® est√† al costat del pin GND i puc clavar o connectar un led sense cap circuit o placa.
// "ledPin" √©s una variable constant i s'anomena aix√≠ per l'usuari, utilitzant camelCase i referint-nos
// al que fa aquest pin.
char* letters[] = {
  ".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..",    // A-I
  ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.",  // J-R
  "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.."          // S-Z
};
// M√©s amunt i m√©s abaix tinc dos arrays composats cadascun d'ells per arrays interns i cada array intern
// est√† composat de caracters que nom√©s poden ser "." o "-".
// Quan jo crido "letter[0]" el que obtinc ".-" o sigui, la lletra A en codi Morse.
// Aquesta forma de treballar √©s molt dolenta, des d'un punt de vista d'efici√®ncia perqu√® estic utilitzant.
// un byte ( un byte s√≥n 8 bits ) sencer per cada punt o ratlla. 
// Un bit √©s un valor de 0 o 1 i aix√≤ es podria utilitzar per fer els punts o ratlles perqu√® els dos valors
// s√≥n dos estats, o 0 o 1, es podria asignar el 0 al punt i la ratlla l'1, fent-ho m√©s eficient.
// En un byte hi han 8 bits i per aix√≤ es podrien fer 256 caracters diferents.
// Quants bytes de mem√≤ria necesitarem utilitzant bytes o bits per codificar Morse?
// Aproximadament el Morse t√© uns 109 punts o ratlles pels n√∫meros o lletres, de la manera m√©s eficient
// tindriem un √∫s de 14 bytes i de la manera menys eficient 872 bytes.
// Hem de tenir en compte
// De fet ASCII utilitza 7 bits per crear 128 caracters ( de 0 a 127 ).
// "*" √©s molt important, ja que ens indica que √©s un punter, "[]" ens indica que √©s una array,
//  "numbers" m'indica el valor de l'array, i char m'indica el tipus d'element ( que s√≥n caracters ) que hi ha dins
// de l'array.
// L'array de sota es diu numbers per√≤ est√† constituit per caracters, perqu√® tant els n√∫meros com les lletres
// estan constituides per "." o "-" que s√≥n caracters
  char* numbers[] = {
  "-----", ".----", "..---", "...--", "....-", ".....", "-....", "--...", "---..", "----."};

void setup() {
  pinMode(ledPin, OUTPUT);
  Serial.begin(9600);
  // En el setup o configuraci√≥ del microcontrolador indiquem que el pin 13 que ara es diu "ledPin" sigui √©s una sortida o "Output"
  // Indiquem a l'arduino que es comuniqui amb l'ordinador a traves del port serial o serie i comenci a una velocitat de 
  // 9600 bauds o simbols/segon que s√≥n aprox. 9600 bits/segon.
}
  

void loop() {
  // El loop √©s el codi principal, i el que el seu nom indica que es repeteix sense parar en un "loop".
  // "char" signica que utilitzem una variable de tipus caracter i l'anomenem "ch".
  // "Serial.available" significa si est√† disponible la comunicaci√≥ serie o "serial monitor" que comunica  el microcontrolador
  // arduino amb el nostre ordinador o dispositiu.
  // La comunicaci√≥ entre arduino i l'ordinador √©s complexa: 
  // Primer pas: l'ordinador envia dades al monitor serie a traves de l'USB per un mecanisme que s'anomena "USB to Serial"
  // Segon pas: la transformaci√≥ anterior d'USB to Serial la fa un xip especial dintre d'Arduino.
  // Tercer pas: les dades en format serie arriben a una part del microcontrolador anomenada UART que significa 
  // "Universal Asynchronous Receiver Transmiter"
  // Quart pas: l'UART envia les dades que rep a una mem√≤ria temporal o "buffer" que pot enmagatzemar 128 bytes fins que s'elimina en
  // el moment que es llegeix -Soy Marticon -by Miguel Angel
  // La funci√≥ serial available retorna el n√∫mero de bytes de dades en el "buffer" que estan esperant per ser llegits. Si no hi ha cap missatge
  // esperant a ser llegit, la funci√≥ retorna a 0
  // La funci√≥ "Serial.read" el que fa √©s llegir el primer o el seg√ºent caracter disponible i l'emmagatzema a la variable "ch"
  // El s√≠mbol >= o <= s'utilitza per comparar amb el n√∫mero d'ASCII que correspon per la lletra "a" per tant, podriem canviar l'a
  // pel n√∫mero 97 i la z √©s el n√∫mero 122.
  // Els altres caracters que podem canviar serien 'A' pel n√∫mero 65, Z pel n√∫mero 90.
  // El caracter '0' correspon al n√∫mero 48 i el caracter '9' correspon al n√∫mero 57.
  // El caracter ' ' correspon al n√∫mero 32.
  // Els condicionals que hi han dintre del condicional general "Serial.avaliable" el que fan √©s dir es que si el caracter √©s 
  // entre la a i la z le restes el valor -a
  // Imaginem que la primera lletra √©s una 'c', que equival al n√∫mero 99, llavors si li restem la 'a' que √©s 97 quedaria un n√∫mero 2.
  // El n√∫mero 2 est√† dintre d'un ([]) √©s a dir, dintre d'una array i correspondria al tercer element de l'array de les lletres.
  // Aquest tercer element √©s "-.-."
  // Un altre exemple seria la 'H' estaria avaluat en un altre condicional, el de les mayuscules, aquest caracter equival 
  // al n√∫mero 72, i li he de restar la 'A' que equival al n√∫mero 65, per tant ch - 'A' √©s 7 que √©s el vuit√© element de l'array
  // de maj√∫scula [7] i letters[7] √©s "...." .
  // Per qu√© s'ha de restar?
  // Per conexier la posici√≥ de la lletra a l'array, perqu√® hem possat l'array ordenat 
  // des de la 'a' fins la 'z' i des de la 'A' fins la 'Z'
  // Ara tenim el n√∫mero per exemple letters[7] igual a "...." i el que volem √©s aplicar una funci√≥.
  // Aquesta funci√≥ √©s la funci√≥ "flashSequence" que agafar√† l'element vuit√© de l'array com a arguments 

    char ch;
  if (Serial.available() > 0) {
    ch = Serial.read();
    if (ch >= 'a' && ch <= 'z') {
      flashSequence(letters[ch - 'a']);
    }
    else if (ch >= 'A' && ch <= 'Z') {
      flashSequence(letters[ch - 'A']);
    }
    else if (ch >= '0' && ch <= '9') {
      flashSequence(numbers[ch - '0']);
    }
    else if (ch == ' ') {
      delay(dotDelay * 4);  // gap between words  
    }
  }
}
// El "void flashSequence()" √©s una funci√≥ que rep un argument
// El que fa amb aquest argument √©s utilitzar un punter i seguir la seq√ºencia que es troba amb letters[7]
// que √©s "....", aquest quatre caracters o punts s√≥n una seq√ºencia de caracters ordenada gracies al punter*
// El codi seg√ºent el que fa √©s amb la posici√≥ 'i' inicial de 0 que √©s el pointer al principi de l'array "...."
// I el que fa √©s que mentre (While) aquest element 'i' de la seq√ºencia no sigui (!) = NULL, es a dir mentres 
// hi hagi un caracter, crida una funci√≥ diferent anomenada "flashDotOrDash" que rep com a argument el valor de 'i'
// concret en aquella seq√ºencia.
// Despr√©s de rebre'l passa el seg√ºent valor de 'i', si la 'i' era el primer ".", la i++ primera o i = i+1 √©s 
// el segon punt ".". I aix√≠ fins al cinqu√® punt que s'atura tot, perqu√© √©s NULL, es a dir, no hi ha cinqu√® punt.
// El Delay serveix per deixar espai entre lletres o sequences.
  void flashSequence(char* sequence) {
  int i = 0;
  while (sequence[i] != NULL) {
    flashDotOrDash(sequence[i]);
    i++;
  }
  delay(dotDelay * 3);    // gap between letters
}
// La funci√≥ "flashSequence" que llegeix una determinada lletra que rep com a argument, letters[7] i reconeix que 
// est√† formada per "...." i crida la funci√≥ "flashDotOrDash" fins que s'acaben els punts o ratjes i deixa un espai
// al final per indicar que √©s una lletra.
// La funci√≥ "flashDorOrDash" t√© un parametre intern anomenat "dotOrDash". Aquesta funci√≥ sempre encen un led, i sempre
// el deixa un temps enc√©s o delay. En el cas que sigui una ratlla, el fa 3 vegades m√©s llarg que un punt, gracies
// a un condicional "if" o en cas contrari "else". No diem si √©s una ratlla, diem si no √©s un punt
void flashDotOrDash(char dotOrDash) {
  digitalWrite(ledPin, HIGH);
  if (dotOrDash == '.') {
    delay(dotDelay);           
  }
  else { 
    // must be a dash 
    delay(dotDelay * 3);           
  }
  digitalWrite(ledPin, LOW);    
  delay(dotDelay); // gap between flashes
}
// El "loop" √©s un bucle i continuament crida a la funci√≥ "flashSequence" que el que fa √©s llegir cada lletra i convertirles
// en punts i ratlles, aquesta funci√≥ crida a la funci√≥ "flashDotOrDash" continuament que fa que s'encenguin els leds segon
// els punts i ratlles. Sempre hem de dividir un codi en diverses funcions, primer per fer-lo m√©s modular i entendre que fa 
// cada funci√≥ i a m√©s ens fa m√©s facil el manteniment i canvis futurs.
    </code>
    </pre>

<h2>Input i Output: Entrades i sortides</h2>
<p>Les entrades i sortdes poden ser de dues maneres diferents, digitals o anal√≤giques, les digitals poden 
ser de 0 voltso de 3,3 volts i en altres plaques arduino, poden ser 0 volts i 5 volts. Les anal√≤giques
serien graduals, de 0 a 3,3 volts o 5 volts en 2**n pasos, sent "n" el n√∫mero de bits.</p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">

const int outPin = 3;
// pinMode √©s una funci√≥ predeterminada o "built-in", vol dir que est√† predefinida en el llenguatje
// arduino i sempre ha de rebre 2 argument o parametres, el primer sempre ha de ser un n√∫mer enter o "int"
// (integer) que correspon al n√∫mero de pin que volem conectar (en aquet cas 3), el segon argument √©s el mode
// que pot ser OUTPUT que significa sortida, o INPUT que significa entrada, tamb√© existeix INPUT_PULLUP
void setup() {
  pinMode(outPin, OUTPUT);
  Serial.begin(9600); //Miguel Angel
  Serial.println("Enter 1 or 0");
}

void loop() {
  if (Serial.available() > 0) {
    char ch = Serial.read();
    if (ch == '1') {
      digitalWrite(outPin, HIGH);
    }
    else if (ch == '0') {
      digitalWrite(outPin, LOW);
    }
  }
}
</code></pre>      
      <p> Quan tenim una entrada hem de possar mode input i en comptes de fer un digitalWrite que fem a les sortides hem de fer un digitalRead per obtenir l'entrada, que nom√©s pot ser un valor digital de 0 o 1 (binari).
    Si el voltatge √©s menor a 2,5 volts es traduir√† com un 0, en canvi si √©s superior com un 1</p>

<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">

    const int inputPin = 5;

    void setup() {
        pinMode(inputPin, INPUT);
        Serial.begin(9600);
    }

    void loop() {
        int reading = digitalRead(inputPin);
        Serial.println(reading);
        delay(1000);
    }

</code></pre>  

<p>// El pullup estabilitza la senyal que rep per a que la transcripci√≥ a binari (0 i 1) sigui correcta. Si analitzem el que
// passa amb un oscil¬∑loscopi (mesura les oscil¬∑lacions de la corrent) si mirem un oscil¬∑loscopi unveurem que hi han 
// pujades i baixades quan premo el bot√≥ no baixa de forma ideal sin√≥ que t√© alguns pics que es diuen rebots 
// (bouncing / debouncing) en el cas de debouncing √©s m√©s correcte ja que el senyal per defecte √©s inestable i el que fem
// √©s estabilitzar-lo -> desrebotar.</p>
                    
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
const int inputPin = 5;

void setup() {
  pinMode(inputPin, INPUT_PULLUP);
  Serial.begin(9600);
}

void loop() {
  int reading = digitalRead(inputPin);
  Serial.println(reading);
  delay(1000);
}
</code></pre>
<p> Negaci√≥. El signe d'admiraci√≥ "!" significa negar la variable que es posa despr√©s del signe.</p>
<p> Hi ha dos variables inicials, que son constants per definici√≥ del codi. La variable ledPin es el pin el qual conectem
el led, que es 13 normalment. I el pin 5 es un pin on conectem un interruptor per entrada de dades. El pin 5 esta enc√©s per defecte
perque li hem dit que es un input pull-up, significa que l'interruptor deixa pasar la corrent per defecte. Si fos un input nom√©s 
estaria a 0, es a dir, l'interruptor estaria obert. La variable switch open esta al principi amb valor 1 i quan movem el bot√≥, 
l'apaguem perqu√© la variable switchOpen que estava a 1 es transforma a !switchOpen que esta a 0. I si li torno a negar, sortira 1.</p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int inputPin = 5;
    const int ledPin = 13
    void setup() {
     pinMode(ledPin, OUTPUT);
     pinMode(inputPin, INPUT_PULLUP);
    }
    void loop() {
     int switchOpen = digitalRead(inputPin);
     digitalWrite(ledPin, ! switchOpen);
    }
    </code></pre>
<p> Clica a la imatge seg√ºent per veure la simulaci√≥ </p>
<a href = "https://www.tinkercad.com/things/6kmvYJBnQFx-circuit-54-monk" target = "_blank"> <img src = "54.PNG"> </a>
<p> Toggles. </p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int inputPin = 5;
    const int ledPin = 13;
    int ledValue = LOW;

    void setup()  {
    pinMode(inputPin, INPUT_PULLUP);
    pinMode(ledPin, OUTPUT);
    }
    void loop()  {
    if (digitalRead(inputPin) == LOW) {
     ledValue = ! ledValue;
     digitalWrite(ledPin, ledValue);
  }
}
</code></pre>
<a href = "https://www.tinkercad.com/things/ijQ7CKiIRbu-circuit-55-monk" target = "_blank"> <img src = "55.PNG"> </a>

<p>soluci√≥ amb llibreria </p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int inputPin = 5;
    const int ledPin = 13;
    int ledValue = LOW;
    
    void setup()  {
    pinMode(inputPin, INPUT_PULLUP);
    pinMode(ledPin, OUTPUT);
    }
    
    void loop() {
    if (digitalRead(inputPin) == LOW) {
     ledValue = ! ledValue;
     digitalWrite(ledPin, ledValue); 
     delay(500);
    }
    }
</code></pre>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
<p>El "contact bounce" podr√≠em traduir-ho com a rebot de contacte, √©s un problema com√∫ a diferents dispositius com per exemple interruptors mec√†nics, 
  reles (interruptor que canvia la posici√≥ d'una palanca interna mitjan√ßant electromagnestisme), contactes de bateria. Tots aquest elements
tenen en com√∫ que estan fets per metalls el√†stics, de forma que quan jo apreto un interruptor mec√†nic el metall que tanca el circuit rebota 
diverses vegades sobre el contacte, provocant una inestabilitat en el senyal.</p>
      #include <Bounce2.h>
        const int inputPin = 5;
        const int ledPin = 13;
        int ledValue = LOW;
        Bounce bouncer = Bounce(); 
    // La maj√∫scula

        void setup() {
        pinMode(inputPin, INPUT_PULLUP);
        pinMode(ledPin, OUTPUT);
        bouncer.attach(inputPin);
        // bouncer.interval(50); // interval in ms
        }

        void loop() {
        if (bouncer.update() && bouncer.read() == LOW) { // Linea clau perqu√®
          ledValue = ! ledValue;
          digitalWrite(ledPin, ledValue);
        }
        }
 </code>
</pre>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">

    const int outputPin = 3;

void setup() {
  pinMode(outputPin, OUTPUT);
  Serial.begin(9600);
  Serial.println("Enter Volts 0 to 5"); // Demana que l'usuari que entri per la consola o srial monitor de l'ARDUINO IDE introdueixi un n√∫mero entre 0 i 5
} // println significa imprimeix una linea i li apliquem en la sintaxi del punt a la classe serial pot rebre diversos parametres, si els posem entre cometes s'escriu tal cual i si no, escriu el valor de la variable

void loop() {
  if (Serial.available() > 0) { // Serial.avalable √©s un m√®tode que espera car√†cters, major a 0 √©s que hi ha car√†cters
    float volts = Serial.parseFloat(); // parseFloat √©s una funci√≥ o m√®tode que s'aplica a l'objecte serial i la seva funci√≥ √©s parsejar o analitzar el contingut de car√†cters que arriba per port serial i si √©s de tipus decimal o floating point number o variable tipus float. Les variables float inclouen les variables int. Tamb√© existeix parseInt que nom√©s acceptaria n√∫meros enters
   // El float volts el que fa √©s crear un espai a la mem√≤ria de l'ordinador anomenat volts que hauria de ser del tipus floating point number que emmagatzemar√† el que li arribi del port serial per l'usuari, o sigui, emmagatzema el n√∫mero decimal quue escriu l'usuari
  int pwmValue = volts * 255.0 / 5.0; // Els volts no serveixen directament perqu√®
    analogWrite(outputPin, pwmValue);
  }
}
</code></pre>
        <p> El "const int outputPin" defineix el pin de sortida constant que no es pot canviar. Despr√©s de definir
            el pin de sortida 3 i en output (sortida) i la velocitat bauds (9600), el codi demana que escrigui a la consola
            del programa Arduino IDE: Enter volts 0-5.</p>
            <p> Al loop principal comprova que hi hagi car√†cters escrits a la consola, despr√©s agafa el valor que hem 
            donat i el guarda en la variable volts. El valor pot ser en decimals perqu√® posa float ("Floating point number").
            El m√®tode parseFloat l'apliquem amb la sintaxi del punt al objecte Serial (Que es posa en maj√∫scula, normalment 
            seria una classe en maj√∫scula) i agafa el valor de la consola s√®rie</p>
            <p> La variable pwmValue √©s entera (int o "integer") i el que fa √©s convertir el valor de volts (0-5) a valors
            de 0-255, que √©s el numero de bits (2^8=256). Si fos un ESP32-S3 de 14 bits tal com indica el data
            sheet o fulla de caracteristiques de el ESP32-S3la linea de codi seria:
            "Serial.println("Enter Volts 0-3.3")
            "int pwmValue = volts * 16384.0 / 3.3" </p>
            
            <p> El ESP32-S3 te l'avantatge de tenir m√©s resoluci√≥, es a dir,  pot donar 16384 valors diferents entre 0-3,3 volts
                Aix√≥ pot que no es noti en un led, per√≥ es nota en un motor, on l'ESP32 permet accedir a m√©s velocitats diferents. Els
                motors poden arribar a 16 bits, que es 2^16 o 65536 valors diferents, depenent del tipus de motor, pot ser observat o no </p>
<h2>N√∫meros aleatoris, perqu√® s√≥n importants i com es fan</h2>
    <p>La funci√≥ random deriva de la funci√≥ rnd del llenguatge C i C++, i funciona de la mateixa manera. No genera n√∫meros
    aleatoris, sin√≥ pseudoaleatoris, perqu√® estan creats per un algorisme o algoritme anomenat "Generador lineal congruencial".
    Aquest algoritme √©s determinista, es a dir que sempre donar√† els mateixos resultats. La funci√≥ random necessita una
    llavor o seed per generar els n√∫meros i si no s'indica acostuma a ser 1 o 0, en arduino √©s 1. Donarem un exeple matematic</p>

<h1>Generaci√≥ de Nombres Pseudoaleatoris: LCG + Arduino</h1>

  <h2>1. Algorisme LCG (Linear Congruential Generator)</h2>
  <p>
    L‚Äôalgorisme congruencial lineal genera seq√º√®ncies pseudoaleat√≤ries segons la f√≥rmula de recursi√≥:
  </p>
  <div>
    \[
      X_{n+1} \;=\; \bigl(a \cdot X_n + c\bigr)\;\bmod\; m
    \]
   
  </div>
  <p>On:</p>
  <ul>
    <li><strong>\(X_n\)</strong> = valor anterior.</li>
    <li><strong>\(a\)</strong> = multiplicador.</li>
    <li><strong>\(c\)</strong> = increment.</li>
    <li><strong>\(m\)</strong> = m√≤dul.</li>
    <li><strong>\(X_0\)</strong> = llavor inicial (seed).</li>
  </ul>

  <h3>Exemple Num√®ric Pas a Pas</h3>
  <p>Suposem:</p>
  <ul>
    <li>\(a = 5\)</li>
    <li>\(c = 3\)</li>
    <li>\(m = 16\)</li>
    <li>\(X_0 = 7\)</li>
  </ul>
  <ol>
    <li>
      \(X_1 = (5 \times 7 + 3) \bmod 16 = 38 \bmod 16 = 6\)
    </li>
    <li>
      \(X_2 = (5 \times 6 + 3) \bmod 16 = 33 \bmod 16 = 1\)
    </li>
    <li>
      \(X_3 = (5 \times 1 + 3) \bmod 16 = 8  \bmod 16 = 8\)
    </li>
    <li>
      \(X_4 = (5 \times 8 + 3) \bmod 16 = 43 \bmod 16 = 11\)
    </li>
    <li>
      \(X_5 = (5 \times 11 + 3) \bmod 16 = 58 \bmod 16 = 10\)
    </li>
  </ol>
  <p><strong>Seq√º√®ncia completa:</strong> 7, 6, 1, 8, 11, 10</p>

  <h1>N√∫meros aleatoris i arduino</h1>
      <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
      void setup() {
  Serial.begin(9600);
}

void loop() {
  int number = random(1, 7); //genera numeros aleatoris entre 1 i 7 que siguin enters, amb una llavor 0
  Serial.println(number);
  delay(500); 
}   
      </code></pre>
      <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
        void setup() {
  Serial.begin(9600);
  randomSeed(analogRead(0)); //genera numeros aleatoris de forma potent. Si dintre de randomSeed posem un n√∫mero, sempre
        //sortira el mateix n√∫mero aleatori com pasa amb el <a href="https://pompeu.neocities.org/arduino/random/seed">
          exemple del profesor</a> on podem canviar la seed o llavor i comprovar-ho
        //analog read llegeix valors de 0 a 1023 de la entrada A0, sempre esta llegint i sempre t√© un soroll de fons
        // de forma que genera numeros aleatoris al soroll de fons de forma que fem numeros aleatoris de numeros aleatoris
        //
}

void loop() {
  int number = random(1, 7);
  Serial.println(number);
  delay(500); 
}
        <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.11.8/umd/popper.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.min.js"></script>

</body>
</html>
